name: Release
on:
  push:
    tags:
      - "v*"
  workflow_dispatch:

jobs:
  release:
    permissions:
      contents: write
    strategy:
      fail-fast: false
      matrix:
        platform: [macos-latest, windows-latest]

    runs-on: ${{ matrix.platform }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install Rust stable
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.platform == 'macos-latest' && 'x86_64-apple-darwin,aarch64-apple-darwin' || '' }}

      - name: Rust cache
        uses: swatinem/rust-cache@v2

      - name: Install frontend dependencies
        run: |
          npm install
          cd web && npm install

      - name: Create .env.local file for Next.js build
        shell: bash
        run: |
          # Create .env.local in the correct location (src/ for Next.js app)
          echo "NEXT_PUBLIC_POSTHOG_KEY=${{ secrets.NEXT_PUBLIC_POSTHOG_KEY }}" > .env.local
          echo "NEXT_PUBLIC_POSTHOG_HOST=${{ secrets.NEXT_PUBLIC_POSTHOG_HOST }}" >> .env.local

          # Verify the file was created correctly
          echo "Created .env.local with PostHog configuration:"
          cat .env.local | sed 's/=.*/=***/' # Show keys but hide values

          # Also export for Rust compilation (option_env! reads at compile time)
          echo "NEXT_PUBLIC_POSTHOG_KEY=${{ secrets.NEXT_PUBLIC_POSTHOG_KEY }}" >> $GITHUB_ENV
          echo "NEXT_PUBLIC_POSTHOG_HOST=${{ secrets.NEXT_PUBLIC_POSTHOG_HOST }}" >> $GITHUB_ENV

      - name: Verify PostHog secrets are set
        shell: bash
        env:
          POSTHOG_KEY: ${{ secrets.NEXT_PUBLIC_POSTHOG_KEY }}
          POSTHOG_HOST: ${{ secrets.NEXT_PUBLIC_POSTHOG_HOST }}
        run: |
          if [ -z "$POSTHOG_KEY" ]; then
            echo "::error::NEXT_PUBLIC_POSTHOG_KEY secret is empty or missing!"
            exit 1
          else
            echo "✓ NEXT_PUBLIC_POSTHOG_KEY is present (length: ${#POSTHOG_KEY})"
          fi

          if [ -z "$POSTHOG_HOST" ]; then
            echo "::warning::NEXT_PUBLIC_POSTHOG_HOST is empty, will use default"
          else
            echo "✓ NEXT_PUBLIC_POSTHOG_HOST is present: $POSTHOG_HOST"
          fi

      - name: Check Secrets
        shell: bash
        env:
          PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
          KEY_PASSWORD: ${{ secrets.TAURI_KEY_PASSWORD }}
        run: |
          if [ -z "$PRIVATE_KEY" ]; then
            echo "::error::TAURI_PRIVATE_KEY is empty or missing!"
            exit 1
          else
            echo "TAURI_PRIVATE_KEY is present (length: ${#PRIVATE_KEY})"
          fi
          
          if [ -z "$KEY_PASSWORD" ]; then
            echo "::warning::TAURI_KEY_PASSWORD is empty or missing!"
          else
            echo "TAURI_KEY_PASSWORD is present"
          fi

      - name: Build the app
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_KEY_PASSWORD }}
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          NEXT_PUBLIC_POSTHOG_KEY: ${{ secrets.NEXT_PUBLIC_POSTHOG_KEY }}
          NEXT_PUBLIC_POSTHOG_HOST: ${{ secrets.NEXT_PUBLIC_POSTHOG_HOST }}
        with:
          tagName: ${{ github.ref_name }}
          releaseName: "v__VERSION__"
          releaseBody: "See the assets to download this version and install."
          releaseDraft: false
          prerelease: false
          args: ${{ matrix.platform == 'macos-latest' && '--target universal-apple-darwin' || '' }}

      - name: Verify PostHog key is embedded in build
        shell: bash
        env:
          POSTHOG_KEY: ${{ secrets.NEXT_PUBLIC_POSTHOG_KEY }}
        run: |
          echo "Checking if PostHog key is embedded in the built JavaScript..."
          # Extract first 10 chars of key for safe searching (avoid exposing full key in logs)
          KEY_PREFIX="${POSTHOG_KEY:0:10}"

          # Search in the built output directory
          if grep -r "$KEY_PREFIX" out/ > /dev/null 2>&1; then
            echo "✓ PostHog key found in built output - analytics will work!"
          else
            echo "::error::PostHog key NOT found in built output!"
            echo "This means environment variables were not properly injected during Next.js build."
            echo "Check that .env.local was created before 'npm run build' was executed."
            exit 1
          fi

      - name: Debug - Check build output
        shell: bash
        run: |
          echo "Checking build output files..."
          if [[ "${{ matrix.platform }}" == "macos-latest" ]]; then
            find src-tauri/target/universal-apple-darwin/release/bundle -type f
          else
            echo "Windows build files:"
            find src-tauri/target/release/bundle -type f
          fi

      - name: Upload assets to Vercel Blob
        if: matrix.platform == 'macos-latest' || matrix.platform == 'windows-latest'
        shell: bash
        env:
          ZEROHZ_READ_WRITE_TOKEN: ${{ secrets.ZEROHZ_READ_WRITE_TOKEN }}
        run: |
          # Find the built asset based on platform
          if [[ "${{ matrix.platform }}" == "macos-latest" ]]; then
            ASSET_PATH=$(find src-tauri/target/universal-apple-darwin/release/bundle/dmg -name "*.dmg" | head -n 1)
            SIG_PATH="${ASSET_PATH}.sig"
          else
            ASSET_PATH=$(find src-tauri/target/release/bundle/nsis -name "*.exe" | head -n 1)
            SIG_PATH="${ASSET_PATH}.sig"
          fi

          if [ -n "$ASSET_PATH" ]; then
            echo "Found asset: $ASSET_PATH"
            
            # Upload asset to Vercel Blob
            # This script writes the URL to blob-url.txt
            node web/scripts/upload-to-blob.mjs "$ASSET_PATH"
            
            # Prepare data for next job
            mkdir -p updater_data
            cp blob-url.txt updater_data/url.txt
            
            if [ -f "$SIG_PATH" ]; then
              echo "Found signature: $SIG_PATH"
              cp "$SIG_PATH" updater_data/signature.txt
            else
              echo "::error::Signature file not found at $SIG_PATH"
              echo "This indicates that the Tauri build failed to sign the update."
              echo "Check that TAURI_SIGNING_PRIVATE_KEY (or TAURI_PRIVATE_KEY) is correctly set in Secrets."
              
              # Fail the build to prevent deploying a broken update
              exit 1
            fi
            
          else
            echo "No asset found to upload"
            exit 1
          fi

      - name: Upload Updater Data Artifact
        uses: actions/upload-artifact@v4
        with:
          name: updater-data-${{ matrix.platform }}
          path: updater_data/

      - name: Send Webhook Notification
        if: success()
        shell: bash
        run: |
          if [ -n "${{ secrets.WEBHOOK_URL }}" ]; then
            PLATFORM="${{ matrix.platform == 'macos-latest' && 'macOS' || 'Windows' }}"
            curl -X POST -H 'Content-type: application/json' \
            --data "{\"text\":\"Deployment Successful - ${PLATFORM} - Version: ${{ github.ref_name }}\"}" \
            ${{ secrets.WEBHOOK_URL }}
          else
            echo "WEBHOOK_URL secret not found, skipping notification."
          fi

  create-updater-json:
    needs: release
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install dependencies
        run: cd web && npm install

      - name: Download Updater Data
        uses: actions/download-artifact@v4
        with:
          pattern: updater-data-*
          path: updater_data
          merge-multiple: false

      - name: Create and Upload latest.json
        env:
          ZEROHZ_READ_WRITE_TOKEN: ${{ secrets.ZEROHZ_READ_WRITE_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Read data from artifacts
          # Structure: updater_data/updater-data-macos-latest/url.txt
          
          DMG_URL=$(cat updater_data/updater-data-macos-latest/url.txt)
          DMG_SIG=$(cat updater_data/updater-data-macos-latest/signature.txt)
          
          EXE_URL=$(cat updater_data/updater-data-windows-latest/url.txt)
          EXE_SIG=$(cat updater_data/updater-data-windows-latest/signature.txt)
          
          # Get release notes
          RELEASE_DATA=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
            "https://api.github.com/repos/${{ github.repository }}/releases/tags/${{ github.ref_name }}")
          
          NOTES=$(echo "$RELEASE_DATA" | jq -r '.body')
          PUBDATE=$(echo "$RELEASE_DATA" | jq -r '.published_at')
          VERSION="${{ github.ref_name }}"
          # Remove 'v' prefix if present for version field, though Tauri usually handles it. 
          # Let's keep it as is or strip it depending on tauri.conf.json. 
          # Usually tauri.conf.json has 0.1.18, tag is v0.1.18. 
          # The updater response version should match the app version.
          CLEAN_VERSION=${VERSION#v}

          # Create latest.json
          # Note: JSON content must be properly escaped if notes contain special chars.
          # Using jq to construct JSON is safer.
          
          jq -n \
            --arg version "$CLEAN_VERSION" \
            --arg notes "$NOTES" \
            --arg pub_date "$PUBDATE" \
            --arg dmg_url "$DMG_URL" \
            --arg dmg_sig "$DMG_SIG" \
            --arg exe_url "$EXE_URL" \
            --arg exe_sig "$EXE_SIG" \
            '{
              version: $version,
              notes: $notes,
              pub_date: $pub_date,
              platforms: {
                "darwin-universal": {
                  signature: $dmg_sig,
                  url: $dmg_url
                },
                "windows-x86_64": {
                  signature: $exe_sig,
                  url: $exe_url
                }
              }
            }' > latest.json
            
          echo "Generated latest.json:"
          cat latest.json

          # Upload latest.json to Vercel Blob
          node web/scripts/upload-to-blob.mjs "latest.json"

          # Upload latest.json to GitHub Release
          gh release upload "${{ github.ref_name }}" latest.json --clobber --repo ${{ github.repository }}
